<!-- Generated by SpecStory -->

# First Iteration Planning for TTMP (2025-03-23 11:40:28)

_**User**_

Create a clear minimal plan for our first iteration in ttmp/2025-03-23/01-first-iteration.md 

---

_**Assistant**_

I'll create a detailed plan for the first iteration of the Guess The Word game. First, I'll create the directory and file.

---

```bash
mkdir -p ttmp/2025-03-23
```

```
❯ mkdir -p ttmp/2025-03-23

guess-the-word-game on  main on ☁️  ttc (us-east-1) 
❯
```

---

Now I'll create the plan document with a clear structure for implementing the Guess The Word game.

---

```diff
- 
+ # Guess The Word Game - First Iteration Implementation Plan
+ 
+ ## 1. Project Setup
+ - [ ] Initialize React project with Vite
+ - [ ] Install and configure Tailwind CSS
+ - [ ] Install react-toastify
+ - [ ] Set up basic project structure
+   ```
+   src/
+     components/
+     contexts/
+     hooks/
+     types/
+     utils/
+     App.tsx
+     main.tsx
+   ```
+ 
+ ## 2. Core Components Implementation
+ - [ ] Create GameContext for managing game state
+   ```typescript
+   type GameState = 'initial' | 'playing' | 'submitting' | 'win' | 'lose';
+   
+   interface GameContextType {
+     state: GameState;
+     hints: string[];
+     guesses: string[];
+     submitGuess: (guess: string) => Promise<void>;
+     startGame: () => void;
+     restartGame: () => void;
+   }
+   ```
+ 
+ - [ ] Implement base components:
+   - [ ] Title component
+   - [ ] Button component (reusable for START/SUBMIT/RESTART)
+   - [ ] GuessInput component with validation
+   - [ ] HintsList component
+   - [ ] GuessesList component
+   - [ ] LoadingSpinner component
+   - [ ] CompletionMessage component
+ 
+ ## 3. Game Logic Implementation
+ - [ ] Create mock API service for game operations
+   ```typescript
+   interface GameAPI {
+     startGame(): Promise<string>; // Returns first hint
+     submitGuess(guess: string): Promise<{
+       correct: boolean;
+       nextHint?: string;
+       secretWord?: string;
+     }>;
+   }
+   ```
+ 
+ - [ ] Implement input validation
+   ```typescript
+   const isValidGuess = (guess: string): boolean => {
+     return /^[A-Za-z]{1,10}$/.test(guess);
+   };
+   ```
+ 
+ - [ ] Implement guess submission logic with loading state
+ 
+ ## 4. UI Implementation
+ - [ ] Style components with Tailwind CSS
+   - [ ] Responsive layout (mobile-first)
+   - [ ] Color scheme for hints/guesses
+   - [ ] Loading spinner styling
+   - [ ] Button states (disabled/enabled)
+ 
+ - [ ] Configure toast notifications
+   ```typescript
+   const showToast = (message: string) => {
+     toast(message, {
+       position: "top-center",
+       autoClose: 2000,
+       hideProgressBar: true,
+     });
+   };
+   ```
+ 
+ ## 5. Game Flow Implementation
+ - [ ] Initial screen with START button
+ - [ ] Main game screen with:
+   - [ ] Hints/guesses display area
+   - [ ] Input field and submit button
+   - [ ] Loading state handling
+   - [ ] Win/lose state handling
+   - [ ] RESTART button implementation
+ 
+ ## 6. Testing & Validation
+ - [ ] Test game flow scenarios:
+   - [ ] Winning game
+   - [ ] Losing game
+   - [ ] Invalid inputs
+   - [ ] Repeated guesses
+ - [ ] Test responsive design
+ - [ ] Test in Chrome and Mobile Safari
+ 
+ ## Technical Constraints
+ - Maximum 5 hints and guesses
+ - Words limited to 10 characters
+ - ASCII characters only (A-Z, case insensitive)
+ - Toast notifications visible for 2 seconds
+ - Portrait orientation for mobile
+ - Chrome and Mobile Safari support only
+ 
+ ## Next Steps
+ After approval of this plan, we'll proceed with:
+ 1. Project setup and dependency installation
+ 2. Core component implementation
+ 3. Game logic implementation
+ 4. UI styling and responsive design
+ 5. Testing and refinement
+ 
+ Would you like me to proceed with implementing this plan? Please confirm if this structure aligns with your vision for the game. 
```

---

I've created a comprehensive implementation plan for the first iteration of the Guess The Word game. The plan is structured into 6 main sections:

1. Project Setup - Basic infrastructure and dependencies
2. Core Components Implementation - All necessary React components and game context
3. Game Logic Implementation - Core game mechanics and API interface
4. UI Implementation - Styling and responsive design
5. Game Flow Implementation - User interaction flow and state management
6. Testing & Validation - Ensuring everything works as expected

The plan includes code snippets for key interfaces and functions, clear checkboxes for tracking progress, and maintains all the constraints specified in the requirements document.

Would you like me to proceed with implementing this plan, starting with the project setup? Or would you like to make any adjustments to the plan first?

---

_**User**_

Add a short overview section to the plan to give context

---

_**Assistant**_

I'll add an overview section at the beginning of the plan.

---

```diff
  # Guess The Word Game - First Iteration Implementation Plan
+ 
+ ## Overview
+ This is the implementation plan for the first iteration of a word guessing game built with React and Tailwind CSS. The game presents players with hints to guess a secret word, with up to 5 attempts allowed. Key features include:
+ 
+ - Simple, responsive UI that works on both desktop and mobile
+ - Single-player gameplay with immediate feedback
+ - Input validation and error handling via toast notifications
+ - Loading states for asynchronous operations
+ - Mock API implementation for game logic
+ 
+ The implementation focuses on core gameplay mechanics while keeping the UI clean and minimal. Features like turn counters, keyboard UI, and advanced accessibility are planned for future iterations.
  
  ## 1. Project Setup
```

---

I've added a concise overview section that:
1. Introduces the project and its core technology stack
2. Outlines the main gameplay mechanic
3. Lists the key features being implemented in this iteration
4. Sets expectations by mentioning what's being left for future iterations

This overview should help anyone reading the plan quickly understand the scope and goals of this first iteration. Would you like me to make any adjustments to the overview, or shall we proceed with implementation?

---

_**User**_

Make a mermaid diagram and a paragraph with also bullet point lists about the implementation of the game algorithm.

---

_**Assistant**_

I'll add a new section about the game algorithm with both a Mermaid diagram and detailed explanation.

---

```diff
  
  The implementation focuses on core gameplay mechanics while keeping the UI clean and minimal. Features like turn counters, keyboard UI, and advanced accessibility are planned for future iterations.
+ 
+ ## Game Algorithm
+ 
+ The game follows a simple state machine pattern where each action transitions the game between well-defined states. The core algorithm handles user input validation, guess processing, and game state management.
+ 
+ ```mermaid
+ stateDiagram-v2
+     [*] --> Initial
+     Initial --> Playing: Click START
+     Playing --> Submitting: Submit Guess
+     Submitting --> Playing: Incorrect Guess (< 5 attempts)
+     Submitting --> Win: Correct Guess
+     Submitting --> Lose: 5th Incorrect Guess
+     Win --> Initial: Click RESTART
+     Lose --> Initial: Click RESTART
+ ```
+ 
+ ### Core Algorithm Components:
+ 
+ Game State Management:
+ - Tracks current game state (initial, playing, submitting, win, lose)
+ - Maintains arrays of hints and guesses
+ - Handles state transitions based on user actions and game rules
+ 
+ Input Processing:
+ - Validates user input against constraints:
+   * ASCII characters only (A-Z)
+   * Maximum length of 10 characters
+   * Case-insensitive comparison
+   * No empty submissions
+   * No duplicate guesses
+ 
+ Guess Processing:
+ - Handles guess submission workflow:
+   * Shows loading state during API calls
+   * Processes API response
+   * Updates game state based on guess result
+   * Manages hint revelation
+   * Tracks guess count
+   * Determines win/lose conditions
+ 
+ Error Handling:
+ - Manages invalid input scenarios:
+   * Shows toast for invalid characters
+   * Shows toast for duplicate guesses
+   * Handles API errors gracefully
+   * Prevents submissions during loading state
+ 
+ ### Implementation Strategy:
+ 1. Implement state machine using React Context
+ 2. Create mock API with simulated network delay
+ 3. Implement input validation as a separate utility
+ 4. Use React hooks for managing component-level state
+ 5. Implement error handling at both UI and data layers
  
  ## 1. Project Setup
```

---

I've added a comprehensive game algorithm section that includes:

1. A Mermaid state diagram showing the game's state transitions
2. Detailed breakdown of core algorithm components:
   - Game State Management
   - Input Processing
   - Guess Processing
   - Error Handling
3. A clear implementation strategy that aligns with our React-based approach

The Mermaid diagram visualizes the game's state machine, making it easy to understand the flow between different states and the actions that trigger transitions. Each state and transition is clearly labeled, matching our implementation requirements.

The bullet points break down the technical implementation details while keeping them organized and easy to reference. Would you like me to make any adjustments to this section?

---

_**User**_

use rtk-query for the state across the application

---

_**Assistant**_

I'll modify the plan to incorporate RTK Query for state management. This will give us better data fetching, caching, and state management capabilities.

---

```diff
  - Input validation and error handling via toast notifications
  - Loading states for asynchronous operations
+ - Centralized state management with RTK Query
+ - Optimistic updates and automatic cache invalidation
  
  The implementation focuses on core gameplay mechanics while keeping the UI clean and minimal. Features like turn counters, keyboard UI, and advanced accessibility are planned for future iterations.
  - [ ] Install and configure Tailwind CSS
  - [ ] Install react-toastify
+ - [ ] Install Redux Toolkit and RTK Query
+   ```bash
+   npm install @reduxjs/toolkit react-redux
+   ```
  - [ ] Set up basic project structure
    ```
    src/
      components/
-     contexts/
+     store/
+       api/
+         gameApi.ts
+       slices/
+         gameSlice.ts
+       store.ts
      hooks/
      types/
    ```
  
- ## 2. Core Components Implementation
- - [ ] Create GameContext for managing game state
+ ## 2. State Management Setup
+ - [ ] Configure RTK Query API slice
    ```typescript
-   type GameState = 'initial' | 'playing' | 'submitting' | 'win' | 'lose';
+   // src/store/api/gameApi.ts
+   import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
  
-   interface GameContextType {
-     state: GameState;
+   export interface GameState {
+     gameId: string;
+     state: 'initial' | 'playing' | 'submitting' | 'win' | 'lose';
      hints: string[];
      guesses: string[];
-     submitGuess: (guess: string) => Promise<void>;
-     startGame: () => void;
-     restartGame: () => void;
-   }
+     secretWord?: string;
+   }
+ 
+   export const gameApi = createApi({
+     reducerPath: 'gameApi',
+     baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
+     tagTypes: ['Game'],
+     endpoints: (builder) => ({
+       startGame: builder.mutation<GameState, void>({
+         query: () => ({
+           url: 'game/start',
+           method: 'POST',
+         }),
+         invalidatesTags: ['Game'],
+       }),
+       submitGuess: builder.mutation<GameState, { gameId: string; guess: string }>({
+         query: ({ gameId, guess }) => ({
+           url: 'game/guess',
+           method: 'POST',
+           body: { gameId, guess },
+         }),
+         invalidatesTags: ['Game'],
+       }),
+       getCurrentGame: builder.query<GameState, void>({
+         query: () => 'game/current',
+         providesTags: ['Game'],
+       }),
+     }),
+   });
+ 
+   export const {
+     useStartGameMutation,
+     useSubmitGuessMutation,
+     useGetCurrentGameQuery,
+   } = gameApi;
+   ```
+ 
+ - [ ] Create game slice for local state
+   ```typescript
+   // src/store/slices/gameSlice.ts
+   import { createSlice, PayloadAction } from '@reduxjs/toolkit';
+ 
+   interface GameUIState {
+     isInputDisabled: boolean;
+     lastError?: string;
+   }
+ 
+   const initialState: GameUIState = {
+     isInputDisabled: false,
+   };
+ 
+   export const gameSlice = createSlice({
+     name: 'gameUI',
+     initialState,
+     reducers: {
+       setInputDisabled: (state, action: PayloadAction<boolean>) => {
+         state.isInputDisabled = action.payload;
+       },
+       setError: (state, action: PayloadAction<string>) => {
+         state.lastError = action.payload;
+       },
+     },
+   });
    ```
  
- - [ ] Implement base components:
+ ## 3. Core Components Implementation
+ - [ ] Implement base components with RTK Query hooks:
    - [ ] Title component
    - [ ] Button component (reusable for START/SUBMIT/RESTART)
    - [ ] GuessInput component with validation
+     ```typescript
+     const GuessInput: React.FC = () => {
+       const [submitGuess] = useSubmitGuessMutation();
+       const { data: gameState } = useGetCurrentGameQuery();
+       // ... component logic
+     };
+     ```
    - [ ] HintsList component
    - [ ] GuessesList component
    - [ ] LoadingSpinner component
    - [ ] CompletionMessage component
  
- ## 3. Game Logic Implementation
- - [ ] Create mock API service for game operations
+ ## 4. Game Logic Implementation
+ - [ ] Implement mock API endpoints to match RTK Query interface
+ - [ ] Add optimistic updates for better UX
    ```typescript
-   interface GameAPI {
-     startGame(): Promise<string>; // Returns first hint
-     submitGuess(guess: string): Promise<{
-       correct: boolean;
-       nextHint?: string;
-       secretWord?: string;
-     }>;
-   }
+   submitGuess: builder.mutation<GameState, { gameId: string; guess: string }>({
+     query: ({ gameId, guess }) => ({
+       url: 'game/guess',
+       method: 'POST',
+       body: { gameId, guess },
+     }),
+     // Optimistically update the UI
+     async onQueryStarted({ guess }, { dispatch, queryFulfilled }) {
+       try {
+         await queryFulfilled;
+       } catch {
+         // Handle error and rollback if needed
+         dispatch(gameSlice.actions.setError('Failed to submit guess'));
+       }
+     },
+   }),
    ```
- 
  - [ ] Implement input validation
-   ```typescript
-   const isValidGuess = (guess: string): boolean => {
-     return /^[A-Za-z]{1,10}$/.test(guess);
-   };
-   ```
- 
- - [ ] Implement guess submission logic with loading state
+ - [ ] Add error handling and retries
  
- ## 4. UI Implementation
+ ## 5. UI Implementation
  - [ ] Style components with Tailwind CSS
    - [ ] Responsive layout (mobile-first)
    ```
  
- ## 5. Game Flow Implementation
+ ## 6. Game Flow Implementation
  - [ ] Initial screen with START button
  - [ ] Main game screen with:
```

---

I've updated the implementation plan to use RTK Query instead of React Context for state management. Key changes include:

1. Added RTK Query and Redux Toolkit to the project dependencies
2. Restructured the project to include a `store` directory with:
   - `api/gameApi.ts` for RTK Query endpoints
   - `slices/gameSlice.ts` for UI-specific state
   - `store.ts` for Redux store configuration

3. Replaced the Context-based state management with:
   - RTK Query endpoints for API calls (`startGame`, `submitGuess`, `getCurrentGame`)
   - A Redux slice for UI-specific state (input disabled state, error messages)
   - Optimistic updates for better UX
   - Automatic cache invalidation using tags

4. Updated the component implementation section to show how components will use RTK Query hooks

Benefits of this approach:
1. Automatic loading and error states
2. Built-in caching and cache invalidation
3. Optimistic updates for better UX
4. DevTools integration for debugging
5. TypeScript support out of the box
6. Reduced boilerplate compared to manual REST API calls

Would you like me to make any adjustments to this RTK Query implementation plan?

---

_**User**_

only client side state

---

_**Assistant**_

I'll modify the plan to use RTK for client-side state only, without the API endpoints since we'll manage everything on the client. This will simplify our implementation while keeping the benefits of Redux for state management.

---

Cancelled

---



---



---

